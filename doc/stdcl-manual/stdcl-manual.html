<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>STDCL Reference Manual</title>
  <meta name="generator" content="Amaya, see http://www.w3.org/Amaya/" />
  <style type="text/css" title="Amaya theme">
/* Modern style for Amaya Editor Lite */

/* default rules for the whole document */
body {
    font-size: 12pt;
    font-family: Times New Roman,Times,serif; /* Helvetica, Arial, sans-serif; */
    font-weight: normal;
    font-style: normal;
    color: black;
    background-color: white;
    line-height: 1.2em;
    margin-left: 4em;
    margin-right: 2em;
   }

/* paragraphs */
p  {
    padding: 0;
    margin-top: 1em;
    margin-bottom: 1em;
    text-align: left;
   }

/* headings */
h1 {
    font-size: 180%;
    font-weight: bold;
    font-style: normal;
    font-variant: small-caps;
    text-align: left;
    padding: 0;
    margin-top: 1.7em;
    margin-bottom: 1.7em;
   }
h2 {
    font-size: 150%;
    font-weight: bold;
    font-style: normal;
    padding: 0;
    margin-top: 1.5em;
    margin-bottom: 1.1em;
   }
h3 {
    font-size: 130%;
    font-weight: bold;
    font-style: normal;
    padding: 0;
    margin-top: 1.3em;
    margin-bottom: 1.1em;
   }
h4 {
    font-size: 110%;
    font-weight: bold;
    font-style: normal;
    padding: 0;
    margin-top: 1.1em;
    margin-bottom: 1.1em;
   }
h5 {
    font-size: 100%;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin-top: 1em;
    margin-bottom: 1em;
   }
h6 {
    font-size: 100%;
    font-weight: normal;
    font-style: italic;
    padding: 0;
    margin-top: 1em;
    margin-bottom: 1em;
   }

/* divisions */
div {
    padding: 0;
    margin-top: 0em;
    margin-bottom: 0em;
   }

/* lists */
ul, ol {
    padding: 0 0 0 3em;
    margin-top: 1em;
    margin-bottom: 1em;
   }
ul ul, ol ol, ul ol, ol ul {
    margin-top: 1em;
    margin-bottom: 1em;
   }
li {
    padding: 0;
    margin-top: 1em;
    margin-bottom: 1em;
    text-align: left;
   }
li p {
    margin-top: 1em;
    margin-bottom: 1em;
   }
dl {
    padding: 0;
    margin-top: 1em;
    margin-bottom: 1em;
    margin-left: 1em;
   }
dl dl {
    margin-top: 0em;
    margin-bottom: 0em;
   }
dt {
    padding: 0;
    font-weight: bold;
    margin-top: .3em;
    margin-bottom: .3em;
   }
dd {
    padding: 0;
    margin-top: .3em;
    margin-left: 3em;
    margin-bottom: .3em;
   }
dl p {
    margin-top: .3em;
    margin-bottom: .3em;
   }

/* inline */
strong {
    font-weight: bold;
   }
em {
    font-style: italic;
   }
code {
    font-family: Courier New, Courier, monospace;
   }
ins {
    background-color: yellow;
    text-decoration: underline;
   }
del {
    text-decoration: line-through;
   }

/* anchors */
a[href] {
    color: blue;
    text-decoration: underline;
   }

/* end */
  </style>
</head>

<body>
<p><img alt="" src="img/bdt.jpg" width="201" height="70" /></p>

<h1 style="text-align:center;margin-left:auto;margin-right:auto;"><span
style="font-family: Times New Roman,Times,serif"><span
style="font-family: Arial,Helvetica,sans-serif">STDCL</span></span> </h1>

<h2 style="text-align:center;margin-left:auto;margin-right:auto;"><span
style="font-family: Times New Roman,Times,serif"><span
style="font-family: Arial,Helvetica,sans-serif">A Simplified C Interface for
OpenCL</span></span></h2>

<p style="text-align:center;margin-left:auto;margin-right:auto;">Copyright ©
2009-2010 Brown Deer Technology, LLC</p>

<p style="text-align:center;margin-left:auto;margin-right:auto;"><span
style="font-size: 10pt"><span
style="font-family: Times New Roman,Times,serif"><em>Verbatim copying and
distribution of this entire document is </em></span></span><span
style="font-family: Times New Roman,Times,serif"><span
style="font-size: 10pt"><em>permitted </em></span></span><span
style="font-size: 10pt"><span
style="font-family: Times New Roman,Times,serif"><em>in any medium, provided
this notice is preserved.</em></span></span></p>
<hr />

<h2>Contents</h2>
<ul>
  <li><a href="#Name">Name</a></li>
  <li><a href="#Version">Version</a></li>
  <li><a href="#Synopsis">Synopsis</a></li>
  <li><a href="#Descriptio">Description</a></li>
  <li><a name="Applicatio1" id="Applicatio1" href="#Applicatio">Application
    Programming Interface (API)</a></li>
  <li style="margin-left:2em;"><a href="#Default">Default Contexts</a></li>
  <li style="margin-left:2em;"><a href="#Dynamic">Dynamic CL Program
  Loader</a></li>
  <li style="margin-left:2em;"><a href="#Memory">Memory Management</a></li>
  <li style="margin-left:2em;"><a href="#Kernel">Kernel Management</a></li>
  <li style="margin-left:2em;"><a href="#Synchroniz">Synchronization</a></li>
  <li style="margin-left:2em;"><a href="#Environmen">Environment
  Variables</a></li>
  <li><a href="#Examples">Examples</a></li>
  <li><a href="#Manual">Manual Pages</a></li>
</ul>
<hr />

<h2><a name="Name" id="Name">Name</a></h2>

<p><span style="font-family: Times New Roman,Times,serif"><span
style="font-family: Arial,Helvetica,sans-serif">STDCL - Standard Compute Layer
Interface</span></span></p>

<p></p>
<hr />

<h2><a name="Version" id="Version">Version</a></h2>

<p><span
style="font-family: Courier New,Courier,monospace">STDCL_VERSION_STR</span></p>

<p><span
style="font-family: Courier New,Courier,monospace">STDCL_VERSION_HEX</span></p>

<p></p>
<hr />

<h2><a name="Synopsis" id="Synopsis">Synopsis</a></h2>
<pre><span style="font-family: Courier New,Courier,monospace"><span style="font-family: Times New Roman,Times,serif">#include &lt;stdcl.h&gt;</span></span>

<span style="font-family: Times New Roman,Times,serif"><span style="font-family: Courier New,Courier,monospace">Link with -lstdcl.</span> </span></pre>
<dl>
  <dt>Default Contexts</dt>
    <dd><span style="font-family: Courier New,Courier,monospace"><span
      style="font-family: Times New Roman,Times,serif"><span
      style="font-family: Courier New,Courier,monospace">stddev, stdcpu,
      stdgpu, stdrpu</span></span></span></dd>
  <dt>Dynamic CL Program loader</dt>
    <dd><span style="font-family: Courier New,Courier,monospace"><span
      style="font-family: Times New Roman,Times,serif"><span
      style="font-family: Courier New,Courier,monospace">clopen(), clsym(),
      clclose()</span></span></span></dd>
  <dt>Memory Management</dt>
    <dd><span style="font-family: Courier New,Courier,monospace"><span
      style="font-family: Times New Roman,Times,serif"><span
      style="font-family: Courier New,Courier,monospace">clmalloc(), clfree(),
      clsizeofmem(), clmsync(), clmattach(),
    clmdetach()</span></span></span></dd>
  <dt>Kernel Management</dt>
    <dd><span style="font-family: Times New Roman,Times,serif"><span
      style="font-family: Courier New,Courier,monospace"><span
      style="font-family: Times New Roman,Times,serif"><span
      style="font-family: Courier New,Courier,monospace">clndrange_init1d(),
      clndrange_init2d(), clndrange_init3d(),</span></span></span></span></dd>
    <dd style="font-family: Times New Roman,Times,serif"><span
      style="font-family: Courier New,Courier,monospace">clarg_set(),
      clarg_set_local(), clarg_set_global(), </span></dd>
    <dd><span style="font-family: Times New Roman,Times,serif"><span
      style="font-family: Courier New,Courier,monospace"><span
      style="font-family: Times New Roman,Times,serif"><span
      style="font-family: Courier New,Courier,monospace">clfork()</span></span></span></span></dd>
  <dt>Synchronization</dt>
    <dd><span style="font-family: Courier New,Courier,monospace"><span
      style="font-family: Times New Roman,Times,serif">clflush(),
      clwait()</span></span></dd>
  <dt>Environment Variables</dt>
    <dd><span style="font-family: Courier New,Courier,monospace"><span
      style="font-family: Times New Roman,Times,serif">STDDEV, STDCPU, STDGPU,
      STDRPU</span></span></dd>
    <dd></dd>
</dl>
<hr />

<h2><a name="Descriptio" id="Descriptio">Description</a></h2>

<p style="text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">OpenCL provides a host-side
API that allows the careful management of memory and processes on heterogeneous
computing platforms. The level of control is more typically reserved for
conventional operating systems (memory management, process management,
synchronization, etc.). Although this granularity of control is necessary to
support the expansive industry objectives for which OpenCL was designed, the
granularity of control and verbose nature of the API proves to be tedious
within the context of typical software application development. The steps
required for a simple Hello World OpenCL program are tedious and repetitive
from a programmer's perspective. Moreover, some semantics introduced by OpenCL
have more natural and familiar constructs within traditional UNIX programming
that can greatly simplify the use of the API and prove more efficient. As an
example, opaque memory buffers are more naturally managed as memory
allocations; modern UNIX-like operating systems are more than capable of
employing memory virtualization sufficient to allow control over memory
consistency. </span></p>

<p style="text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">STDCL provides a simplified C
interface to OpenCL designed in a style familiar to traditional UNIX/C
programmers. The design and implementation of STDCL is inspired by familiar
APIs designed for different purposes, e.g., stdio.h (for default contexts),
dlopen (for managing OpenCL kernels), malloc (as a replacement for creating
opaque memory buffers), and fork (as a replacement to "enqueueing commands on
the command queue"). In every detail, the approach is to avoid introducing new
inventive syntax and semantics in favor of exploiting permutations of more
familiar syntax and semantics from traditional UNIX. Whether the effort
succeeds is for the programmer to decide.</span></p>

<p></p>
<hr />

<h2><a name="Applicatio" id="Applicatio">Application Programming Interface
(API)</a></h2>

<p>The STDCL interface provides support for <a href="#Default"><em>default
contexts</em></a>, <a href="#Dynamic"><em>dynamic CL program loader</em></a>,
<a href="#Memory"><em>memory management</em></a>, <a href="#Kernel"><em>kernel
execution</em></a>, and <em><a href="#Asynchrono">asynchronous
operations</a></em>. In addition, <a href="#Environmen">environment
variables</a> provide run-time control over certain aspects of the interface.
The STDCL interface is discussed in detail below. </p>

<p></p>

<h3><a name="Default" id="Default">Default Contexts</a></h3>

<p style="text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">STDCL provides several default
contexts similar to the default I/O streams provided by stdio. These default
contexts are defined to include the most typical use-cases. Each default
context is of type </span><span
style="font-family: Courier New,Courier,monospace">CONTEXT,<span
style="font-family: Times New Roman,Times,serif"></span></span> <span
style="font-family: Times New Roman,Times,serif">which is defined as a superset
of the OpenCL type </span><span
style="font-family: Courier New,Courier,monospace">cl_context<span
style="font-family: Times New Roman,Times,serif"></span></span>. <span
style="font-family: Times New Roman,Times,serif">The following default contexts
are provided:</span></p>

<p><span style="font-family: Courier New,Courier,monospace"><strong>CONTEXT*
stddev;</strong></span> </p>

<p style="margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">All devices for a given
platform supported by the OpenCL API.</span></p>

<p><strong><span style="font-family: Courier New,Courier,monospace">CONTEXT*
stdcpu;</span></strong> </p>

<p style="margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">All multi-core CPU processors
for a given platform supported by the OpenCL API.</span></p>

<p><strong><span style="font-family: Courier New,Courier,monospace">CONTEXT*
stdgpu;</span></strong> </p>

<p style="margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">All many-core GPU processors
for a given platform supported by the OpenCL API.</span></p>

<p><span style="font-family: Courier New,Courier,monospace"><strong>CONTEXT*
stdrpu;</strong></span> </p>

<p style="margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">All reconfigurable processors
for a given platform supported by the OpenCL API.</span></p>

<p></p>

<h3><a name="Dynamic" id="Dynamic">Dynamic CL Program Loader</a></h3>

<p style="text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">STDCL provides a convenient
interface for dynamically loading CL programs and accessing OpenCL kernels. The
functions <span
style="font-family: Courier New,Courier,monospace">clopen()</span>, <span
style="font-family: Courier New,Courier,monospace">clsym()</span> and <span
style="font-family: Courier New,Courier,monospace">clclose()</span> are
designed to mirror the semantics of the more familiar functions <span
style="font-family: Courier New,Courier,monospace">dlopen()</span>, <span
style="font-family: Courier New,Courier,monospace">dlsym()</span> and <span
style="font-family: Courier New,Courier,monospace">dlclose()</span> used to
access the Linux dynamic loader. The following functions are provided for
dynamically loading CL programs and accessing OpenCL kernels:</span></p>

<p><strong><span style="font-family: Courier New,Courier,monospace">void*
clopen( CONTEXT* cp, const char* filename, int flags);</span></strong></p>

<p style="text-align:justify;margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">This call opens a file
containing the source or binary program defining one or more OpenCL kernels and
performs the steps necessary to create and build the OpenCL program object. A
handle is returned that can be used in subsequent calls to access the actual
kernels in the program. The handle is valid within the</span> <span
style="font-family: Courier New,Courier,monospace">CONTEXT</span> <span
style="font-family: Times New Roman,Times,serif">specified by </span><span
style="font-family: Courier New,Courier,monospace"><strong>cp<span
style="font-family: Times New Roman,Times,serif"></span></strong></span>. </p>

<p style="text-align:justify;margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">If </span><span
style="font-family: Courier New,Courier,monospace"><strong>filename</strong></span>
<span style="font-family: Times New Roman,Times,serif">is a </span><span
style="font-family: Courier New,Courier,monospace"><span
style="font-family: Times New Roman,Times,serif">NULL</span><span
style="font-family: Times New Roman,Times,serif"></span></span> pointer <span
style="font-family: Times New Roman,Times,serif">then a handle to the OpenCL
program(s) embedded in the host program executable is returned. (See the tool
</span><span style="font-family: Courier New,Courier,monospace">clld<span
style="font-family: Times New Roman,Times,serif"></span></span> <span
style="font-family: Times New Roman,Times,serif">for a description of how to
embed OpenCL source and binary programs into a host program
executable.)</span></p>

<p style="text-align:justify;margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">The </span><strong><span
style="font-family: Courier New,Courier,monospace">flags<span
style="font-family: Times New Roman,Times,serif"></span></span></strong><span
style="font-family: Times New Roman,Times,serif">argument allows control over
the behavior of the function. The flag <span
style="font-family: Courier New,Courier,monospace">CLLD_NOW</span> instructs
the call to perform all of the steps involved with creating and building the
program; the flag <span
style="font-family: Courier New,Courier,monospace">CLLD_LAZY</span> instructs
the call to defer these steps until the handle is first used. The call accepts
a flag set to <span style="font-family: Courier New,Courier,monospace">0</span>
in which case the default behavior <span
style="font-family: Courier New,Courier,monospace">(CLLD_NOW)</span> is
used.</span></p>

<p><strong><span style="font-family: Courier New,Courier,monospace">cl_kernel
clsym( CONTEXT* cp, void* handle, const char* symbol, int
flags);</span></strong></p>

<p
style="margin-left:2em;text-align:justify;font-family: Times New Roman,Times,serif">This
call takes a <strong><span
style="font-family: Courier New,Courier,monospace">handle</span></strong>
returned from a call to <span
style="font-family: Courier New,Courier,monospace">clopen()</span> and returns
the OpenCL kernel specified by <strong><span
style="font-family: Courier New,Courier,monospace">symbol</span></strong>. The
OpenCL kernel is created within the <span
style="font-family: Courier New,Courier,monospace">CONTEXT</span> specified by
<strong>cp</strong>. </p>

<p style="margin-left:2em;text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">The argument <strong><span
style="font-family: Courier New,Courier,monospace">flags</span></strong> allows
control over the behavior of the function. The flag <span
style="font-family: Courier New,Courier,monospace">CLLD_NOW</span> instructs
the call to perform all of the steps involved with creating the kernel; the
flag <span style="font-family: Courier New,Courier,monospace">CLLD_LAZY</span>
instructs the call to defer these steps until the kernel is first used. The
call accepts a flag set to <span
style="font-family: Courier New,Courier,monospace">0</span> in which case the
default behavior <span
style="font-family: Courier New,Courier,monospace">(CLLD_NOW)</span> is
used.</span></p>

<p><strong><span style="font-family: Courier New,Courier,monospace">int
clclose( CONTEXT* cp, void* handle);</span></strong></p>

<p style="margin-left:2em;text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">This call decrements the
reference count on the associated handle. If the reference count drops to zero
then the associated OpenCL program source or binary is unloaded and the
associated file is closed. Under normal usage this call is used to safely
release the OpenCL programs created by a call to <span
style="font-family: Courier New,Courier,monospace">clopen()</span>.</span></p>

<p></p>

<h3><a name="Memory" id="Memory">Memory Management</a></h3>

<p style="text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">STDCL provides functions for
allocating and managing memory that may be shared between the host and OpenCL
co-processor devices. Memory may be allocated with clmalloc() and used
transparently as the global memory for kernel execution on a OpenCL device. The
programmer uses a single pointer representing the allocated memory which may be
re-attached to various CL contexts using clmattach() and clmdetach(). Memory
consistency can be maintained using the clmsync() function which synchronizes
memory between the host and OpenCL co-processor devices. </span><span
style="font-family: Times New Roman,Times,serif">The following functions are
provided for OpenCL memory management.</span></p>

<p><strong><span style="font-family: Courier New,Courier,monospace">void*
clmalloc( CONTEXT* cp, size_t size, int flags);</span></strong></p>

<p style="text-align:justify;margin-left:2em"><span
style="font-family: Times New Roman,Times,serif">This call allocates memory
suitable for sharing between OpenCL co-processor devices within a CL context.
The size of the allocation is specified in bytes. The memory is not cleared.
The last argument is used to pass flags to control the behavior of function.
The flag <span
style="font-family: Courier New,Courier,monospace">CL_MEM_DETACHED</span> may
be used to allocate memory that is not attached to a CL context in which case
<strong style="font-family: Courier New,Courier,monospace">cp</strong> must be
0. If <strong><span
style="font-family: Courier New,Courier,monospace">flags</span></strong> is 0
the default behavior is to allocate memory attached to a specified CL context.
</span></p>

<p><strong><span style="font-family: Courier New,Courier,monospace">void
clfree( void* ptr);</span></strong></p>

<p style="text-align:justify;margin-left:2em">This call frees memory allocated
with <span
style="font-family: Courier New,Courier,monospace">clmalloc()</span>. The
memory specified by <strong><span
style="font-family: Courier New,Courier,monospace">ptr</span></strong> can be
either attached or detached from a CL context. Calling <span
style="font-family: Courier New,Courier,monospace">clfree()</span> with
<strong><span
style="font-family: Courier New,Courier,monospace">ptr</span></strong> equal to
<span style="font-family: Courier New,Courier,monospace">0</span> is considered
an error. </p>

<p><strong><span style="font-family: Courier New,Courier,monospace">size_t
clsizeofmem(void* ptr);</span></strong></p>

<p style="text-align:justify;margin-left:2em"><span
style="font-family: Times New Roman,Times,serif">This call returns the size in
bytes of the memory allocated with <span
style="font-family: Courier New,Courier,monospace">clmalloc()</span>.
</span></p>

<p><strong><span style="font-family: Courier New,Courier,monospace">cl_event
clmsync( CONTEXT* cp, unsigned int devnum, void* ptr, int
flags);</span></strong></p>

<p style="text-align:justify;margin-left:2em"><span
style="font-family: Times New Roman,Times,serif">This call is used to
synchronize memory between the host platform and OpenCL co-processor devices.
The memory specified by <strong><span
style="font-family: Courier New,Courier,monospace">ptr</span></strong> must
have been allocated by <span
style="font-family: Courier New,Courier,monospace">clmalloc()</span> and
associated with a CL context. </span></p>

<p style="text-align:justify;margin-left:2em"><span
style="font-family: Times New Roman,Times,serif">The behavior of <span
style="font-family: Courier New,Courier,monospace">clmsync()</span> is
controlled by the <strong><span
style="font-family: Courier New,Courier,monospace">flags</span></strong>
argument which must be set with either <span
style="font-family: Courier New,Courier,monospace">CL_MEM_HOST</span> or <span
style="font-family: Courier New,Courier,monospace">CL_MEM_DEVICE</span>. These
flags are mutually exclusive and it is an error to set both or none. In
addition the flags <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_WAIT</span> and
<span style="font-family: Courier New,Courier,monospace">CL_EVENT_NOWAIT</span>
control the blocking behavior for the call. For a blocking call the flag <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_RELEASE</span> may
be specified to force the call to release and OpenCL events created as a result
of the call.</span><span style="font-family: Times New Roman,Times,serif">If
the flag <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_RELEASE</span> is
not specified the programmer is responsible for releasing the returned event
with the OpenCL call <span
style="font-family: Courier New,Courier,monospace">clReleaseEvent()</span>.</span></p>

<p style="text-align:justify;margin-left:2em"><span
style="font-family: Times New Roman,Times,serif">The following examples
demonstrate typical uses of <span
style="font-family: Courier New,Courier,monospace">clmsync()</span>:</span></p>

<p style="margin-left:2em;">Non-blocking sync to device memory:</p>

<p style=" margin-bottom: 0em; margin-top: 0em; ;margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clmsync(stdgpu,0,ptr,CL_MEM_DEVICE|CL_EVENT_NOWAIT);</span></p>

<p style="margin-left:2em;">Non-blocking sync to host memory:</p>

<p style="margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clmsync(stdgpu,0,ptr,CL_MEM_HOST|CL_EVENT_NOWAIT);</span></p>

<p style="margin-left:2em;">Blocking sync to device memory:</p>

<p style="margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clmsync(stdgpu,0,ptr,CL_MEM_DEVICE|CL_EVENT_WAIT);</span></p>

<p style="margin-left:2em;">Blocking sync to host with release of event:</p>

<p style="margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clmsync(stdgpu,0,ptr,CL_MEM_HOST|CL_EVENT_WAIT|CL_EVENT_RELEASE);</span></p>

<p><strong><span style="font-family: Courier New,Courier,monospace">int
clmattach( CONTEXT* cp, void* ptr );</span></strong></p>

<p style="text-align:justify;margin-left:2em"><span
style="font-family: Times New Roman,Times,serif">This call is used to attach
memory allocated by <span
style="font-family: Courier New,Courier,monospace">clmalloc()</span> to a CL
context. </span><span style="font-family: Times New Roman,Times,serif">In order
to change the attachment of memory from one CL context to another, the memory
must first be unattached using a call to <span
style="font-family: Courier New,Courier,monospace">clmdetach()</span>. It is an
error to call with a <strong><span
style="font-family: Courier New,Courier,monospace">ptr</span></strong> to
memory that is already attached to a CL context. </span></p>

<p><span style="font-family: Courier New,Courier,monospace"><strong>int
clmdetach( void* ptr );</strong></span></p>

<p style="text-align:justify;margin-left:2em"><span
style="font-family: Times New Roman,Times,serif">This call is used to detach
memory from a CL context. The memory must have been allocated by <span
style="font-family: Courier New,Courier,monospace">clmalloc()</span>.</span></p>

<h3><a name="Kernel" id="Kernel">Kernel Management</a></h3>

<p style="text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">STDCL provides simplified
interfaces for setting up the index-space and arguments for kernel execution.
Executing a kernel on an OpenCL co-processor device is supported using clfork()
which allows blocking and non-blocking execution behavior. The following
functions are provided for OpenCL kernel management.</span></p>

<p style="line-height:1em;"><strong><span
style="font-family: Courier New,Courier,monospace">clndrange_t
clndrange_init1d( gtoff0,gtsz0,ltsz0); <br />
clndrange_t clndrange_init2d( gtoff0,gtsz0,ltsz0, gtoff1,gtsz1,ltsz1); <br />
clndrange_t clndrange_init3d( gtoff0,gtsz0,ltsz0, gtoff1,gtsz1,ltsz1,
gtoff2,gtsz2,ltsz2);</span></strong></p>

<p style="margin-left:2em;text-align:justify;">The <span
style="font-family: Courier New,Courier,monospace">clndrange_init*()</span>
functions are used to <em>initialize</em> a variable of type <span
style="font-family: Courier New,Courier,monospace">clndrange_t</span> used to
store the OpenCL index-space over which a kernel is to execute. These functions
will be implemented as macros to allow for struct initialization in C. The
arguments <strong><span
style="font-family: Courier New,Courier,monospace">gtoff</span></strong>,
<strong><span
style="font-family: Courier New,Courier,monospace">gtsz</span></strong> and
<strong><span
style="font-family: Courier New,Courier,monospace">ltsz</span></strong>
represent the global offset, global size and local size of the index-space for
a given dimension, respectively. As an example, the following initializes a two
dimensional OpenCL NDRange with no offsets over a global index space of size
512 by 2048 with a local work group size of 4 by 16:</p>

<p style="margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clndrange_t ndr =
clndrange_init2d( 0,512,4 0,2048,16);</span></p>

<p><strong style="font-family: Courier New,Courier,monospace">void clarg_set(
cl_kernel krn, unsigned int argnum, Tn arg );</strong></p>

<p style="margin-left:2em;text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">This call is used to set the
argument of an OpenCL kernel for arguments of intrinsic non-pointer type that
are to be passed by value. The size of the argument is inferred from the type
of the argument and may be a vector type, e.g., <span
style="font-family: Courier New,Courier,monospace">cl_float4</span>. </span></p>

<p><strong style="font-family: Courier New,Courier,monospace">void
clarg_set_global( cl_kernel krn, unsigned int argnum, void* ptr );</strong></p>

<p style="margin-left:2em;text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">This call is used to set the
argument of an OpenCL kernel for arguments that are pointers to global memory
as defined in the OpenCL specification. The memory must have been allocated by
<span style="font-family: Courier New,Courier,monospace">clmalloc()</span> in
the appropriate CL context of the kernel. </span></p>

<p><strong style="font-family: Courier New,Courier,monospace">void
clarg_set_local( cl_kernel krn, unsigned int argnum, size_t sizeb
);</strong></p>

<p style="text-align:justify;margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">This call is used to set the
argument of an OpenCL kernel for arguments that are pointers to local memory as
defined in the OpenCL specification. Local memory of size <strong><span
style="font-family: Courier New,Courier,monospace">sizeb</span></strong> bytes
will be allocated for use by the OpenCL kernel.</span></p>

<p><strong style="font-family: Courier New,Courier,monospace">cl_event clfork(
CONTEXT* cp, unsigned int devnum, cl_kernel krn, clndrange* ndr, int flags
);</strong></p>

<p style="text-align:justify;margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">This call is used to execute a
kernel on the OpenCL co-processor device specified by <strong><span
style="font-family: Courier New,Courier,monospace">devnum</span></strong>. The
arguments for the kernel must be set prior to the call to <span
style="font-family: Courier New,Courier,monospace">clfork()</span> using the
<span style="font-family: Courier New,Courier,monospace">clarg_set*()</span>
functions described above. The kernel is executed over an index-space of
work-items defined by <strong><span
style="font-family: Courier New,Courier,monospace">ndr</span></strong>.</span></p>

<p style="text-align:justify;margin-left:2em;"><span
style="font-family: Times New Roman,Times,serif">The behavior of <span
style="font-family: Courier New,Courier,monospace">clfork()</span> may be
controlled using the flags <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_WAIT</span> or
<span
style="font-family: Courier New,Courier,monospace">CL_EVENT_NOWAIT</span>.
Specifying the flag <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_NOWAIT</span> will
cause <span style="font-family: Courier New,Courier,monospace">clfork()</span>
to return immediately. Specifying the flag <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_WAIT</span> will
cause <span style="font-family: Courier New,Courier,monospace">clfork()</span>
to block until the kernel execution is complete. Including the flag <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_RELEASE</span> will
cause the event associated with the kernel execution to be released for
blocking calls to <span
style="font-family: Courier New,Courier,monospace">clfork()</span>. If the flag
<span
style="font-family: Courier New,Courier,monospace">CL_EVENT_RELEASE</span> is
not specified the programmer is responsible for releasing the returned event
with the OpenCL call <span
style="font-family: Courier New,Courier,monospace">clReleaseEvent()</span>.</span></p>

<p style="margin-left:2em;">The following examples demonstrate typical uses of
<span style="font-family: Courier New,Courier,monospace">clfork()</span>:</p>

<p style="margin-left:2em;">Blocking execution of a kernel on device number
0:</p>

<p style="margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clfork( stdgpu, 0, my_krn,
&amp;ndr, CL_EVENT_WAIT);</span></p>

<p style="margin-left:2em;">Non-blocking execution of a kernel on device number
2 automatically releasing the associated event:</p>

<p style="margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clfork( stdgpu, 2, my_krn,
&amp;ndr, CL_EVENT_NOWAIT|CL_EVENT_RELEASE);</span></p>

<p></p>

<h3><a name="Synchroniz" id="Synchroniz">Synchronization</a></h3>

<p style="text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">STDCL provides functions for
synchronization to manage the inherently asynchronous operations enabled by
OpenCL per device within each CL context.</span></p>

<p><span style="font-family: Courier New,Courier,monospace"><strong>int
clflush( CONTEXT* cp, unsigned int devnum, int flags );</strong></span></p>

<p style="margin-left:2em;text-align:justify;">This call is used to flush all
commands enqueued in the command queue associated with the OpenCL device
specified by the device number <strong><span
style="font-family: Courier New,Courier,monospace">devnum</span></strong>
within the specified CL context. For typical OpenCL implementations this is
necessary to force the execution of commands without blocking on the host. A
call to <span
style="font-family: Courier New,Courier,monospace">clflush()</span> is
non-blocking and will return immediately. At present the argument <strong><span
style="font-family: Courier New,Courier,monospace">flags</span></strong> should
be set to <span style="font-family: Courier New,Courier,monospace">0</span>.</p>

<p><strong style="font-family: Courier New,Courier,monospace">cl_event clwait(
CONTEXT* cp, unsigned int devnum, int flags );</strong></p>

<p style="margin-left:2em;text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">This call is used to block on
the completion of all commands enqueued in the command queue associated with
the OpenCL device specified by the device number <strong><span
style="font-family: Courier New,Courier,monospace">devnum</span></strong>
within the specified CL context. </span></p>

<p style="margin-left:2em;text-align:justify;"><span
style="font-family: Times New Roman,Times,serif">The <strong><span
style="font-family: Courier New,Courier,monospace">flags</span></strong>
argument is used to control the behavior of the call as follows. The flag <span
style="font-family: Courier New,Courier,monospace">CL_KERNEL_EVENT</span> will
cause the call to block on completion of all enqueued kernel events enqueued by
calls to <span
style="font-family: Courier New,Courier,monospace">clfork()</span>. the flag
<span style="font-family: Courier New,Courier,monospace">CL_MEM_EVENT</span>
will cause the call to block on completion of all enqueued memory events
enqueued by call to <span
style="font-family: Courier New,Courier,monospace">clmsync()</span>. The flags
<span style="font-family: Courier New,Courier,monospace">CL_KERNEL_EVENT</span>
and <span
style="font-family: Courier New,Courier,monospace">CL_MEM_EVENT</span> may be
combined in a single call. Including the flag <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_RELEASE</span> will
cause all OpenCL events to be released before <span
style="font-family: Courier New,Courier,monospace">clwait()</span>
returns.</span> If the flag <span
style="font-family: Courier New,Courier,monospace">CL_EVENT_RELEASE</span> is
not specified the programmer is responsible for releasing all events with the
OpenCL call clReleaseEvent(). </p>

<p style="margin-left:2em;text-align:justify;">The following examples
demonstrate typical uses of <span
style="font-family: Courier New,Courier,monospace">clwait()</span>:</p>

<p style="margin-left:2em;">Block on completion of all kernel execution events
on OpenCL device number 0 releasing all events:</p>

<p style="margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clwait( stdgpu, 0,
CL_KERNEL_EVENT|CL_EVENT_RELEASE );</span></p>

<p style="margin-left:2em;">Block on completion of all memory events on OpenCL
device number 2 releasing all events:</p>

<p style="margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clwait( stdgpu, 2,
CL_MEM_EVENT|CL_EVENT_RELEASE );</span></p>

<p style="margin-left:2em;">Block on completion of all kernel and memory events
on OpenCL device number 2 releasing all events:</p>

<p style="margin-left:4em"><span
style="font-family: Courier New,Courier,monospace">clwait( stdgpu, 2,
CL_KERNEL_EVENT|CL_MEM_EVENT|CL_EVENT_RELEASE );</span></p>

<p></p>

<h3><a name="Environmen" id="Environmen">Environment Variables</a></h3>

<p>The run-time behavior of STDCL can be controlled using environment variables
as follows.</p>

<p><strong><span style="font-family: Courier New,Courier,monospace">STDDEV,
</span></strong><span
style="font-family: Courier New,Courier,monospace"><strong>STDCPU,
</strong></span><span
style="font-family: Courier New,Courier,monospace"><strong>STDGPU,
</strong></span><span
style="font-family: Courier New,Courier,monospace"><strong>STDRPU</strong></span></p>

<p style="margin-left:2em;">Each default CL context is can be controlled by the
associated environment variable. A value of 0 will disable the CL context. A
non-zero value will set a limit on the number of devices used for the CL
context. </p>

<p></p>
<hr />

<h2><a name="Examples" id="Examples">Examples</a></h2>

<p><span style="font-family: Times New Roman,Times,serif">The following example
shows the use of STDCL for a simple program that adds two vectors on a GPU or a
CPU:</span></p>

<div style="background-color:#e8e8e8;">
<pre>/* example #1 */

#include &lt;stdio.h&gt;
#include &lt;strings.h&gt;
#include &lt;stdcl.h&gt;

#define SIZE 1024

int main()
{
   int i;

   CONTEXT* cp = (stdgpu)? stdgpu : stdcpu;

   void* clh = clopen(cp, "add_vec.cl",CLLD_NOW);
   cl_kernel k_addvec = clsym(clh, "addvec_kern", CLLD_NOW);

   float* aa = (float*)clmalloc(cp,SIZE*sizeof(float),0);
   float* bb = (float*)clmalloc(cp,SIZE*sizeof(float),0);
   float* cc = (float*)clmalloc(cp,SIZE*sizeof(float),0);

   for(i=0;i&lt;SIZE;i++) {
      aa[i] = 111.0f * i;
      bb[i] = 222.0f * i;
   }

   bzero(cc,SIZE*sizeof(float));

   clndrange_t ndr = clndrange_init1d(0,SIZE,64);

   clmsync(cp,0,aa,CL_MEM_DEVICE|CL_EVENT_NOWAIT);
   clmsync(cp,0,bb,CL_MEM_DEVICE|CL_EVENT_NOWAIT);

   clarg_set_global(k_addvec,0,aa);
   clarg_set_global(k_addvec,1,bb);
   clarg_set_global(k_addvec,2,cc);

   clfork(cp,0,k_addvec,&amp;ndr,CL_EVENT_NOWAIT);

   clmsync(cp,0,cc,CL_MEM_HOST|CL_EVENT_NOWAIT);

   clwait(cp,0,CL_MEM_EVENT|CL_KERNEL_EVENT|CL_EVENT_RELEASE);

   for(i=0;i&lt;SIZE;i++) printf("%f %f %f\n",aa[i],bb[i],cc[i]);

   if (aa) clfree(aa);
   if (bb) clfree(bb);
   if (cc) clfree(cc);

   clclose(cp,clh);
}
  </pre>
</div>

<p></p>

<p><span style="font-family: Times New Roman,Times,serif">The following example
shows the use of STDCL for a simple program that adds two vectors on two
GPU:</span></p>

<div style="background-color:#e8e8e8;">
<pre>/* example #2 */

#include &lt;stdio.h&gt;
#include &lt;strings.h&gt;
#include "stdcl.h"

#define SIZE 1024

int main()
{
   int i,n;

   CONTEXT* cp = stdgpu;

   void* clh = clopen(cp, "add_vec.cl",CLLD_NOW);
   cl_kernel k_addvec = clsym(clh, "addvec_kern", CLLD_NOW);

   float* aa[2];
   float* bb[2];
   float* cc[2];

   aa[0] = (float*)clmalloc(cp,SIZE*sizeof(float)/2,0);
   aa[1] = (float*)clmalloc(cp,SIZE*sizeof(float)/2,0);
   bb[0] = (float*)clmalloc(cp,SIZE*sizeof(float)/2,0);
   bb[1] = (float*)clmalloc(cp,SIZE*sizeof(float)/2,0);
   cc[0] = (float*)clmalloc(cp,SIZE*sizeof(float)/2,0);
   cc[1] = (float*)clmalloc(cp,SIZE*sizeof(float)/2,0);

   for(i=0;i&lt;SIZE/2;i++) {
      aa[0][i] = 111.0f * i;
      aa[1][i] = 111.0f * (SIZE/2 + i);
      bb[0][i] = 222.0f * i;
      bb[1][i] = 222.0f * (SIZE/2 + i);
   }

   bzero(cc[0],SIZE*sizeof(float));
   bzero(cc[1],SIZE*sizeof(float));

   clndrange_t ndr = clndrange_init1d(0,SIZE/2,64);

   clmsync(cp,0,aa[0],CL_MEM_DEVICE|CL_EVENT_NOWAIT);
   clmsync(cp,1,aa[1],CL_MEM_DEVICE|CL_EVENT_NOWAIT);
   clmsync(cp,0,bb[0],CL_MEM_DEVICE|CL_EVENT_NOWAIT);
   clmsync(cp,1,bb[1],CL_MEM_DEVICE|CL_EVENT_NOWAIT);

   clarg_set_global(k_addvec,0,aa[0]);
   clarg_set_global(k_addvec,1,bb[0]);
   clarg_set_global(k_addvec,2,cc[0]);

   clfork(cp,0,k_addvec,&amp;ndr,CL_EVENT_NOWAIT);

   clmsync(cp,0,cc[0],CL_MEM_HOST|CL_EVENT_NOWAIT);

   clflush(cp,0,0);

   clarg_set_global(k_addvec,0,aa[1]);
   clarg_set_global(k_addvec,1,bb[1]);
   clarg_set_global(k_addvec,2,cc[1]);

   clfork(cp,1,k_addvec,&amp;ndr,CL_EVENT_NOWAIT);

   clmsync(cp,1,cc[1],CL_MEM_HOST|CL_EVENT_NOWAIT);

   clflush(cp,1,0);

   clwait(cp,0,CL_MEM_EVENT|CL_KERNEL_EVENT|CL_EVENT_RELEASE);
   clwait(cp,1,CL_MEM_EVENT|CL_KERNEL_EVENT|CL_EVENT_RELEASE);

   for(i=0;i&lt;SIZE/2;i++) printf("%f %f %f\n",aa[0][i],bb[0][i],cc[0][i]);
   for(i=0;i&lt;SIZE/2;i++) printf("%f %f %f\n",aa[1][i],bb[1][i],cc[1][i]);

   if (aa[0]) clfree(aa[0]);
   if (aa[1]) clfree(aa[1]);
   if (bb[0]) clfree(bb[0]);
   if (bb[1]) clfree(bb[1]);
   if (cc[0]) clfree(cc[0]);
   if (cc[1]) clfree(cc[1]);

   clclose(cp,clh);
}
  </pre>
</div>

<p></p>
<hr />

<h2><a name="Manual" id="Manual">Manual Pages</a></h2>

<table border="1">
  <col />
  <col />
  <tbody>
    <tr>
      <td>overview</td>
      <td><a href="#STDLC">stdcl(3)</a></td>
    </tr>
    <tr>
      <td>dynamic loader</td>
      <td><a href="#CLOPEN">clopen(3)</a>, <a href="#CLOPEN">clsym(3)</a>, <a
        href="#CLOPEN">clclose(3)</a></td>
    </tr>
    <tr>
      <td>memory management</td>
      <td><a href="#CLMALLOC">clmalloc(3)</a>, <a
        href="#CLMALLOC">clfree(3)</a>, <a href="#CLMALLOC">clsizeofmem(3)</a>,
        <a href="#CLMSYNC">clmsync(3)</a>, <a
        href="#CLMATTACH">clmattach(3)</a>, <a
        href="#CLMATTACH">clmdetach(3)</a></td>
    </tr>
    <tr>
      <td>kernel management</td>
      <td><a href="#CLARG_SET">clndrange_init1d(3)</a>, <a
        href="#CLARG_SET">clndrange_init2d(3)</a>, <a
        href="#CLARG_SET">clndrange_init3d(3)</a>, 

        <p><a href="#CLARG_SET">clarg_set(3)</a>, <a
        href="#CLARG_SET">clarg_set_global(3)</a>, <a
        href="#CLARG_SET">clarg_set_local(3)</a>, <a href="#CLFORK"></a></p>

        <p><a href="#CLFORK">clfork(3)</a></p>
      </td>
    </tr>
    <tr>
      <td>asynchronous operations</td>
      <td><a href="#CLFLUSH">clflush(3)</a>, <a
      href="#CLWAIT">clwait(3)</a></td>
    </tr>
  </tbody>
</table>

<p></p>
<hr />
<pre><a name="STDLC" id="STDLC">STDLC(3)</a>              Standard Compute Layer (CL) Manual              STDLC(3)



NAME
       stdcl - standard compute layer (CL) library functions

SYNOPSIS
       #include &lt;stdcl.h&gt;

       CONTEXT* stddev;
       CONTEXT* stdcpu;
       CONTEXT* stdgpu;
       CONTEXT* stdrpu;

       Link with -lstdcl.

DESCRIPTION
       The  standard  compute layer (CL) library (libstdcl) provides a simpli-
       fied interface to OpenCL designed to support the most typical use-cases
       in  a  style  inspired by familiar and traditional UNIX APIs for C pro-
       gramming.

       libstdcl provides managed OpenCL contexts  identified  with  a  context
       pointer  that is generally provided as an argument to library functions
       that transparently manage OpenCL constructs such as contexts,  devices,
       memory, kernels and events in a manner that simplifies their use.

       Default Contexts

       libstdcl  provides  several default contexts similar to the default I/O
       streams provided by stdio.  The following  default  contexts  are  pro-
       vided:

       stddev All devices for a given platform supported by the OpenCL API.

       stdcpu All  multi-core CPU processors for a given platform supported by
              the OpenCL API.

       stdgpu All many-core GPU processors for a given platform  supported  by
              the OpenCL API.

       stdrpu All  reconfigurable processors for a given platform supported by
              the OpenCL API.

       Dynamic CL Program Loader

       libstdcl provides a convenient interface  for  dynamically  loading  CL
       programs  and  accessing  CL  kernels.   Using the tool clld CL program
       source and binary files can be embedded  within  special  ELF  sections
       linked  against  other  object files on the host platform to generate a
       single executable.  The set of functions clopen(),  clsym(),  clclose()
       provide  a  convenient interface capable of dynamically loading CL pro-
       grams embedded within the executable as well as from an external  file.
       CL programs.

       Memory Management

       libstdcl provides functions for allocating and managing memory that may
       be shared between the host and CL co-processor devices.  Memory may  be
       allocated  with  clmalloc() and used transparently as the global memory
       for kernel execution on a CL device.   The  programmer  uses  a  single
       pointer  representing  the allocated memory which may be re-attached to
       various CL contexts using clmattach() and clmdetach().  Memory  consis-
       tency can be maintained using the clmsync() function which synchronizes
       memory between host and CL co-processor device.

       Kernel Management

       libstdcl provides simplified interfaces for setting up the  index-space
       and arguments for kernel execution.  Executing a kernel on a particular
       CL co-processor device is supported using clfork() which allows  block-
       ing and non-blocking execution behavior.

       Synchronization

       libstdcl  provides  event  management per device within each context to
       simplify the management of asynchronous multi-device  operations.   The
       function clwait() can be used to block on selected events within one of
       several per-device event lists managed transparently.

EXAMPLE
       The following example shows a very simple program for  calculating  the
       outer product of two vectors using a GPU:

           #include &lt;stdcl.h&gt;

           int main() {

                int n = 1024;

                cl_float* aa = (cl_float*)clmalloc(stdgpu,n,0);
                cl_float* bb = (cl_float*)clmalloc(stdgpu,n,0);
                cl_float* cc = (cl_float*)clmalloc(stdgpu,n,0);

                /* initialize aa and bb */

                void* h = clopen(stdgpu,"outer_prod_kern.cl",0);
                cl_kernel krn = clsym(stdgpu,h,"outer_prod_kern");

                clndrange_t ndr = clndrange_init1d(0,n,4);

                clarg_set(krn,0,n);
                clarg_set_global(krn,1,aa);
                clarg_set_global(krn,2,bb);
                clarg_set_global(krn,3,cc);

                clfork(stdgpu,0,krn,ndr,CL_EVENT_NOWAIT);

                clmsync(stdgpu,0,cc,CL_EVENT_NOWAIT);

                clwait(stdgpu,0,CL_ALL_EVENTS|CL_EVENT_RELEASE);

                clclose(h);

                clfree(aa);
                clfree(bb);
                clfree(cc);

           }

ENVIRONMENT
       Executables  that  use the libstdcl library are affected by environment
       variables that control the behavior of the API.  The environment  vari-
       ables  STDDEV,  STDCPU, STDGPU, STDRPU may be set to pass a string used
       to control the behavior of the respective default contexts when a  pro-
       gram  is executed.  Each string may contain one or more colon-separated
       clauses.

       As an example, the following would force the stdgpu context to use  the
       ATI Stream platform:


              setenv STDGPU platform_name="ATI STREAM"

           A context can be disabled by setting the respective envinoment variable to 0,
           for example, the following will disable the stddev context:

                  setenv STDDEV 0


       The allowed clauses are platform and context dependent.

AUTHOR
       Written by David Richie.

REPORTING BUGS
       Report bugs to &lt;support@browndeertechnology.com&gt;

COPYRIGHT
       Copyright  (C) 2009 Brown Deer Technology, LLC.  Licensed under the GNU
       Lesser General Public License version 3.  There is NO WARRANTY  to  the
       extent permitted by law.

SEE ALSO
       clld(1),   clopen(3),  clsym(3),  clclose(3),  clmalloc(3),  clmsync(),
       clfork(3), clwait(3)



     "libstdcl-1.0"                2010-8-12                          STDLC(3)</pre>
<hr />
<pre><a name="CLOPEN" id="CLOPEN">CLOPEN(3)</a>             Standard Compute Layer (CL) Manual             CLOPEN(3)



NAME
       clopen,  clsym,  clclose,  clerror,  claddr  - programming interface to
       dynamic CL loader

SYNOPSIS
       #include &lt;stdcl.h&gt;

       void* clopen( CONTEXT* cp, const char* filename, int flags);

       cl_kernel clsym( CONTEXT* cp, void* handle,  const  char*  symbol,  int
       flags);

       int claddr( CONTEXT* cp, void* addr, CL_info* info);

       char* clerror( void );

       int clclose( CONTEXT* cp, void* handle);

       Link with -lstdcl.

DESCRIPTION
       The  functions clopen(), clsym(), clclose(), and clerror() implement an
       interface for dynamically loading compute layer (CL) kernels.

       The function clopen() loads the CL source or binary program file  named
       by  the  NULL-terminated  string  filename and returns an opaque handle
       that may be used as a reference in subsequent calls.  If filename is  a
       NULL pointer then a handle for the main program executable is returned.

       The function clsym() takes a handle to a CL source or binary program and
       a  NULL-terminated symbol name and returns the associated CL kernel.  A
       CL context pointer must be specified to identify  the  appropriate  CL
       kernel  to  return.  If handle is NULL then all CL programs loaded into
       the specified CL context are searched.

       The function clclose() decrements the reference count on the associated
       handle.   If  the  reference count drops to zero then the CL program is
       unloaded.  The function clclose() returns the reference count  on  suc-
       cess and -1 on error.

       The  function  clerror() returns a human readable string describing the
       most recent error that has occurred as a result of a call to any of  the
       functions  clopen(),  clsym(),  clclose()  since the last call to cler-
       ror().  If no error has occured NULL is returned.

       The function claddr() takes as an argument a CL  kernel  and  tries  to
       resolve the name and file where it is located.  Information is returned
       in the cl_kernel_info structure:

           struct cl_kernel_info {
                const char* cli_fname;
                CONTEXT* cli_cp;
                unsigned int cli_devnum;
                const char* cli_kname;
           };

       If no matching kernel is found the fields are set  to  NULL.   claddr()
       returns zero on error and non-zero on success.

EXAMPLE
AUTHOR
       Written by David Richie.

REPORTING BUGS
       Report bugs to &lt;support@browndeertechnology.com&gt;

COPYRIGHT
       Copyright  (C) 2009 Brown Deer Technology, LLC.  Licensed under the GNU
       Lesser General Public License version 3 (LGPLv3).  There is NO WARRANTY
       to the extent permitted by law.

SEE ALSO
       clld(1), clload(3), stdcl(3)



libstdcl-1.0                       2010-8-12                         CLOPEN(3)</pre>
<hr />
<pre><a name="CLMALLOC" id="CLMALLOC">CLMALLOC(3)</a>           Standard Compute Layer (CL) Manual           CLMALLOC(3)



NAME
       clmalloc,  clfree,  clsizeofmem - Allocate and free dynamic memory with
       CL bindings for use with co-processor devices

SYNOPSIS
       #include &lt;stdcl.h&gt;

       void* clmalloc( CONTEXT* cp, size_t size, int flags);

       void clfree( void* ptr);

       size_t clsizeofmem(void* ptr);

       Link with -lstdcl.

DESCRIPTION
       clmalloc() allocates memory suitable for sharing between compute  layer
       (CL)  co-processor  devices  within a CL context.  clmalloc() allocates
       size bytes and returns a pointer to the allocated memory.   The  memory
       is not cleared.  If size is 0, then clmalloc() returns a unique pointer
       value that can later be safely passed to clfree().

       clfree() frees the memory space pointed to by ptr, which must have been
       returned   by   a  previous  call  to  clmalloc().   Otherwise,  or  if
       clfree(ptr) has already been called before, the behavior is  undefined.
       It is considered an error to call clfree(ptr) if ptr is 0 or NULL.

       clsizeofmem()  returns the size of the allocated memory associated with
       ptr.  If ptr does not reference memory allocated by a  call  to  clmal-
       loc(),  and  for  which  clfree()  has not been called, the behavior is
       undefined.

RETURN VALUE
       If successful clmalloc(3) returns a pointer  to  the  allocated  memory
       that  is suitably aligned and suitable for sharing with CL co-processor
       devices.  On error, returns NULL.

       clfree() returns no value.

       clsizeofmem() returns the size in bytes of the  memory  pointed  to  by
       ptr.

AUTHOR
       Written by David Richie.

REPORTING BUGS
       Report bugs to &lt;support@browndeertechnology.com&gt;

COPYRIGHT
       Copyright  (C) 2009 Brown Deer Technology, LLC.  Licensed under the GNU
       Lesser General Public License version 3 (LGPLv3).  There is NO WARRANTY
       to the extent permitted by law.

SEE ALSO
       clmattach(3), clmdetach(3), clmsync(3), stdcl(3), malloc(3)



libstdcl-1.0                       2010-8-12                       CLMALLOC(3)</pre>
<hr />
<pre><a name="CLMSYNC" id="CLMSYNC">CLMSYNC(3)</a>            Standard Compute Layer (CL) Manual            CLMSYNC(3)



NAME
       clmsync - Synchronize memory between host and co-processor device

SYNOPSIS
       #include &lt;stdcl.h&gt;

       cl_event  clmsync(  CONTEXT*  cp,  unsigned  int devnum, void* ptr, int
       flags);

       Link with -lstdcl.

DESCRIPTION
       clmsync() is used to synchronize memory between the host and a  compute
       layer (CL) co-processor device.  The memory pointed to by ptr must have
       been created using a call to clmalloc() and associated with a  CL  con-
       text.

       The  behavior  of  clmsync()  is controlled by the flags argument which
       must be set with either CL_MEM_HOST or CL_MEM_DEVICE.  These flags  are
       mutually exclusive and it is an error to set both or none.  The follow-
       ing flags may be used:

       CL_MEM_HOST
              clmsync() will sync the memory on the host.

       CL_MEM_DEVICE
              clmsync() will sync the memory on the device.

       CL_EVENT_WAIT
              clmsync() will block until the operation has completed.

       CL_EVENT_NOWAIT
              clmsync() will return immediately.  The programmer  must  ensure
              that the operation has completed using clwait() or clwaitev().

       CL_EVENT_RELEASE
              Used  with  CL_EVENT_WAIT  to  force clmsync() to release the CL
              event generated by the operation.  If this flag is not used  the
              programmer is responsible for releasing the returned event using
              clReleaseEvent().  This flag has no effect when  CL_EVENT_NOWAIT
              is used.

RETURN VALUE
       On  error  clmsync() will return (cl_event)(-1) and errno is set appro-
       priately.

AUTHOR
       Written by David Richie.

REPORTING BUGS
       Report bugs to &lt;support@browndeertechnology.com&gt;

COPYRIGHT
       Copyright (C) 2009 Brown Deer Technology, LLC.  Licensed under the  GNU
       Lesser General Public License version 3 (LGPLv3).  There is NO WARRANTY
       to the extent permitted by law.

SEE ALSO
       clwait(3), clwaitev(3), clmalloc(3), clfree(3), stdcl(3)



libstdcl-1.0                       2010-8-12                        CLMSYNC(3)</pre>
<hr />
<pre><a name="CLMATTACH" id="CLMATTACH">CLMATTACH(3)</a>          Standard Compute Layer (CL) Manual          CLMATTACH(3)



NAME
       clmattach, clmdetach - Attach and detach memory from a CL context

SYNOPSIS
       #include &lt;stdcl.h&gt;

       int clmattach( CONTEXT* cp, void* ptr );

       int clmdetach( void* ptr );

       Link with -lstdcl.

DESCRIPTION
       clmattach()  is  used to attach memory to a compute layer (CL) context.
       The memory pointed to by ptr must  be  allocated  with  clmalloc()  and
       suitable  for sharing between the host and CL co-processor devices.  In
       order to change the  attachment  of  memory  from  one  CL  context  to
       another,  the  memory  must  first be unattached using a call to clmde-
       tach().  It is an error to pass  clmattach()  memory  that  is  already
       attached to a CL context.

       clmdetach()  is  used  to  detach memory from a CL context.  The memory
       pointed to by ptr must be allocated with clmalloc()  and  suitable  for
       sharing between the host and CL co-processor devices.

       If ptr does not point to memory allocated by clmalloc() the behavior of
       clmattach() and clmdetach() is undefined.

RETURN VALUE
       Both clmattach() and clmdetach() return 0 on success.  On error, -1  is
       returned and errno is set appropriately.

AUTHOR
       Written by David Richie.

REPORTING BUGS
       Report bugs to &lt;support@browndeertechnology.com&gt;

COPYRIGHT
       Copyright  (C) 2009 Brown Deer Technology, LLC.  Licensed under the GNU
       Lesser General Public License version 3 (LGPLv3).  There is NO WARRANTY
       to the extent permitted by law.

SEE ALSO
       clmalloc(3), clfree(3), clmsync(3), malloc(3), stdcl(3)



libstdcl-1.0                       2010-8-12                      CLMATTACH(3)</pre>
<hr />
<pre><a name="CLARG_SET" id="CLARG_SET">CLNDRANGE_INIT(3)</a>     Standard Compute Layer (CL) Manual     CLNDRANGE_INIT(3)



NAME
       clndrange_init1d,  clndrange_init2d,  clndrange_init3d - Initialize the
       index-space (NDRange) for the execution of a CL kernel

SYNOPSIS
       #include &lt;stdcl.h&gt;

       clndrange_t clndrange_init1d( gtoff0,gt0,lt0);

       clndrange_t clndrange_init2d( gtoff0,gt0,lt0, gtoff1,gt1,lt1);

       clndrange_t    clndrange_init3d(    gtoff0,gt0,lt0,     gtoff1,gt1,lt1,
       gtoff2,gt2,lt2);

DESCRIPTION
       clndrange_init()  family  of macros are used to initialize an object of
       type clndrange_t that defines the index-space for the execution of a CL
       kernel.  The values of gtoffn, gtn, ltn define the global index offset,
       global index range and local index range, respectively,  for  dimension
       n.   The  index-space defines the work-group and work-item partitioning
       for the kernel execution.

EXAMPLES
       The initialization of a 1-D index-space of  16  work-items  with  work-
       group size of 2 and no global offset:

               clndrange_t ndr = clndrange_init1d( 0,16,2 );

       The  initialization  of  a 2-D index-space of 64 by 128 work-items with
       work-group size of 2 by 4 with a global work-item offset of 32,64:

               clndrange_t ndr = clndrange_init1d( 32,64,2, 64,128,4 );

AUTHOR
       Written by David Richie.

REPORTING BUGS
       Report bugs to &lt;support@browndeertechnology.com&gt;

COPYRIGHT
       Copyright (C) 2009 Brown Deer Technology, LLC.  Licensed under the  GNU
       Lesser General Public License version 3 (LGPLv3).  There is NO WARRANTY
       to the extent permitted by law.

SEE ALSO
       clndrange_set(3), clfork(3), stdcl(3)



libstdcl-1.0                       2010-8-12                 CLNDRANGE_INIT(3)</pre>
<hr />
<pre><a name="CLARG_SET111" id="CLARG_SET111">CLARG_SET(3)</a>          Standard Compute Layer (CL) Manual          CLARG_SET(3)



NAME
       clarg_set, clarg_set_global, clarg_set_local - Set CL kernel arguments

SYNOPSIS
       #include &lt;stdcl.h&gt;

       void clarg_set( cl_kernel krn, unsigned int argnum, Tn arg);

       void clarg_set_global( cl_kernel krn, unsigned int argnum, void* ptr);

       void  clarg_set_local(  cl_kernel  krn,  unsigned  int  argnum,  size_t
       sizeb);

DESCRIPTION
       clarg_set(), clarg_set_global() and clarg_set_local() are used  to  set
       the argnum argument of the CL kernel krn prior to kernel execution.

       clarg_set()  is  used  for  setting arguments of intrinsic type such as
       cl_int, cl_float or cl_float4, etc.  For  clarg_set()  Tn  can  be  any
       valid scalar or vector type.

       clarg_set_global  is  used  for setting arguments of pointers to global
       memory where ptr points to memory that was allocated using  a  call  to
       clmalloc() and attached to the CL context of the target kernel.

       clarg_set_local()  is  used  for setting arguments of pointers to local
       memory where sizeb indicates the size in bytes of the local memory that
       is to be allocated.

AUTHOR
       Written by David Richie.

REPORTING BUGS
       Report bugs to &lt;support@browndeertechnology.com&gt;

COPYRIGHT
       Copyright  (C) 2009 Brown Deer Technology, LLC.  Licensed under the GNU
       Lesser General Public License version 3 (LGPLv3).  There is NO WARRANTY
       to the extent permitted by law.

SEE ALSO
       clfork(3), clsym(3), clmalloc(3), stdcl(3)



libstdcl-1.0                       2010-8-12                      CLARG_SET(3)</pre>
<hr />
<pre><a name="CLFORK" id="CLFORK">CLFORK(3)</a>             Standard Compute Layer (CL) Manual             CLFORK(3)



NAME
       clfork - Execute a CL kernel

SYNOPSIS
       #include &lt;stdcl.h&gt;

       cl_event  clfork(  CONTEXT*  cp,  unsigned  int  devnum, cl_kernel krn,
       clndrange_t* ndr, int flags);

       Link with -lstdcl.

DESCRIPTION
       clfork() is used to execute a CL kernel on a  specified  compute  layer
       (CL)  co-processor  device.   The  arguments for the kernel must be set
       prior to the call to clfork() using the  clarg_set*()  functions.   The
       kernel is executed over an index-space of work-items defined by ndr.

       The behavior of clfork() can be controlled using the following flags:

       CL_EVENT_WAIT
              clfork() will block until the operation has completed.

       CL_EVENT_NOWAIT
              clfork()  will  return  immediately.  The programmer must ensure
              that the operation has completed using clwait() or clwaitev().

       CL_EVENT_RELEASE
              Used with CL_EVENT_WAIT to force  clfork()  to  release  the  CL
              event  generated by the operation.  If this flag is not used the
              programmer is responsible for releasing the returned event using
              clReleaseEvent().   This flag has no effect when CL_EVENT_NOWAIT
              is used.

RETURN VALUE
       On error clfork() will return (cl_event)(-1) and errno is set appropri-
       ately.

AUTHOR
       Written by David Richie.

REPORTING BUGS
       Report bugs to &lt;support@browndeertechnology.com&gt;

COPYRIGHT
       Copyright  (C) 2009 Brown Deer Technology, LLC.  Licensed under the GNU
       Lesser General Public License version 3 (LGPLv3).  There is NO WARRANTY
       to the extent permitted by law.

SEE ALSO
       clarg_set(3),     clndrange_init(3),    clndrange_set(3),    clwait(3),
       clwaitev(3), stdcl(3)



libstdcl-1.0                       2010-8-12                         CLFORK(3)</pre>
<hr />
<pre><a name="CLFLUSH" id="CLFLUSH">CLFLUSH(3)</a>            Standard Compute Layer (CL) Manual            CLFLUSH(3)



NAME
       clflush - Flush the CL command queue

SYNOPSIS
       #include &lt;stdcl.h&gt;

       int clflush( CONTEXT* cp, cl_uint devnum, int flags);

       Link with -lstdcl.

DESCRIPTION
       clflush()  is  used to flush the OpenCL command queue for device number
       devnum within a CL context.  For certain OpenCL implementations this is
       necessary to initiate operations to be executed asynchronously.

       The flags argument is reserved for future use and presently ignored.

RETURN VALUE
       On  error  clflush() will return (cl_event)(-1) and errno is set appro-
       priately.

AUTHOR
       Written by David Richie.

REPORTING BUGS
       Report bugs to &lt;support@browndeertechnology.com&gt;

COPYRIGHT
       Copyright (C) 2010 Brown Deer Technology, LLC.  Licensed under the  GNU
       Lesser General Public License version 3 (LGPLv3).  There is NO WARRANTY
       to the extent permitted by law.

SEE ALSO
       clfork(3), clmsync(3), clwait(3), stdcl(3)



libstdcl-1.0                       2010-8-12                        CLFLUSH(3)</pre>
<hr />
<pre><a name="CLWAIT" id="CLWAIT">CLWAIT(3)</a>             Standard Compute Layer (CL) Manual             CLWAIT(3)



NAME
       clwait - Block on one or more CL events

SYNOPSIS
       #include &lt;stdcl.h&gt;

       cl_event clwait( CONTEXT* cp, cl_uint devnum, int flags);

       Link with -lstdcl.

DESCRIPTION
       clwait()  is used to block on the completion of one or more outstanding
       events for device number devnum within  a  CL  context.   The  type  of
       events are specified by selecting one or more event lists as described
       below.

       One or more event lists may be selected using a combination of the fol-
       lowing flags:

       CL_KERNEL_EVENT
              Block on events in the ordered kernel event list.

       CL_MEM_EVENT
              Block on events in the ordered memory event list.

       Note that if both kernel and memory event lists are specified, the ker-
       nel event list has first priority.  Specifically, clwait()  will  first
       block  on  all  outstanding kernel events and subsequently block on all
       outstanding memory events.

       The behavior of clwait() can be controlled using the following flags:

       CL_EVENT_RELEASE
              Force clwait() to release all events on upon completion for  all
              events  on  which  it blocks.  If this flag is not used the pro-
              grammer is responsible for releasing the  returned  event  using
              clReleaseEvent().

RETURN VALUE
       On error clwait() will return (cl_event)(-1) and errno is set appropri-
       ately.

AUTHOR
       Written by David Richie.

REPORTING BUGS
       Report bugs to &lt;support@browndeertechnology.com&gt;

COPYRIGHT
       Copyright (C) 2009 Brown Deer Technology, LLC.  Licensed under the  GNU
       Lesser General Public License version 3 (LGPLv3).  There is NO WARRANTY
       to the extent permitted by law.

SEE ALSO
       clfork(3), clmsync(3), clwaitev(3), stdcl(3)



libstdcl-1.0                       2010-8-12                         CLWAIT(3)</pre>
<hr />

<p></p>
</body>
</html>
