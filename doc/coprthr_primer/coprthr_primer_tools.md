# Tools

## CL-ELF: A Real Compilation Model for OpenCL, Finally 

By default OpenCL provides great flexibility, but offers no guidance or support 
for a real compilation model of the kind most programmers would expect. Instead 
this is left as an exercise. COPRTHR provides a set of tools and libraries that 
support a robust compilation model for OpenCL with sensible fallback behaviors. 
At the core of the compilation model is an extension to the standard ELF object 
format (CL-ELF) that provides sections for logically supporting all that is 
possible with OpenCL in terms of cross-compilation. 

The tools include an offline compiler (clcc) capable of generating linkable
object files containing source and binaries for any number of platforms and
devices. Multiple object files can be combined using a linker (clld) to create
a static object or shared library. A full range of options are provided to
allow the programmer complete control over the content of each object file.
Additional utilities are provided to extract information and further manipulate
this extended ELF format. The STDCL dynamic loader provides integrated support
for the CL-ELF format, enabling a programmer to simply link their OpenCL
kernels and access them by symbol name.

The following simple examples demonstrate the use of the offline compiler to
produce a single linkable ELF object file that may used to produce
self-contained executables without the need for JIT compilation of auxiliary
.cl files.

Example 1: Compile three kernels stored in three files to create a linkable 
object file and link this into an application:

	] clcc alpha.cl beta.cl gamma.cl -o all_kernels.o
	] gcc -o my_app.x my_app.c all_kernels.o 

Example 2: Compile the three kernels separately, link them to create a single 
object file, and link this into an application:

	] clcc alpha.cl
	] clcc beta.cl
	] clcc gamma.cl
	] clld alpha.o beta.o gamma.o -o all_kernels.o
	] gcc -o my_app.x my_app.c all_kernels.o

Example 3: Compile the three kernels separately, link them to produce a single 
object file, strip out the source code and only include binaries for an AMD 
Cayman and all Nvidia devices:

~~~
] clcc alpha.cl
] clcc beta.cl
] clcc gamma.cl
] clld -o all_kernels.o -mdevice=amdapp:cayman,nvidia: -b alpha.o beta.o gamma.o
] gcc -o my_app.x my_app.c all_kernels.o
~~~

So where is my kernel? That is the best part about the compilation model. From 
inside the application using the STDCL dynamic loader, kernels are accessed with 
a single call, for example:

	cl_kernel krn_alpha = clsym(stdgpu,"alpha_kernel",CLLD_NOW);

That's it. Simple, efficient, portable and reliable. For programmers who
 actually enjoy the tedious and error prone steps involved with directly
 managing OpenCL kernel code from within their application, this compilation
 model is not for you. 

NOTE: Object files generated by clcc and/or clld can only be combined using 
clld. Attempts to use the standard linker ld for this purpose will, by design, 
cause a link time error due to multiple hash symbol definitions. This feature 
was deliberately introduced since a standard linker cannot properly combine 
sections in the CL-ELF format yet. The standard linker ld is used once to link a 
single CL-ELF file with conventional ELF object files.




## clcc: An Offline Compiler for OpenCL

clcc is an offline compiler for OpenCL kernel source files used to generate a 
linkable ELF object containing multiple binaries targeting multiple platforms
 and devices. The original source code can also be included for subsequent JIT
 compilation on targets for which no binary is included. The ouptut of clcc uses
 an open extension of the standard ELF format (CL-ELF) that enables the
 representation of the full range of cross-compilations avaialable with multiple
 OpenCL platform implementations. The output can be linked as many times as
 necessary using clld, but can only be linked once to produce an ELF object or
 executable file using the conventional linker ld. In order to protect against
 multiple links using ld, hash values are included in CL-ELF object files such
 that multiple values can only be resolved with clld. The following is a
 synopsis of the usage for clcc.

	clcc [options] file1.cl file2.cl ... [-o output.o]

Options:

-b
  : Include only binaries in the CL-ELF object, i.e., do not embed the original 
    source code. This prevents the kernels from being JIT compiled on target 
    platforms and devices not included in the offline compilation.

-c
  : Generate an object file that is linkable with clld. This is the default 
    behavior and the 
    flag is provided only to maintain conventional compiler 
    semantics.

-fopencl
  : Specify the language dialect for compilation to be strict 
    OpenCL, overriding that which is inferred from the file 
    extensions.

-fcuda
  : (Reserved)

-fopenmp
  : (Reserved)

-fstdcl
  : (Reserved)

-h --help
  : Print a 
    brief help message.

-I `<path>`
  : Add `<path>` to the include path for compilation.

-mall
  : Include binaries for all devices supported by all available platforms.

-mavail
  : Include binaries for only those devices available on the host 
    system.

-mdevice=`<devices>`
  : Select exclusive list of devices to include where 
    `<devices>` is a comma separated list with no spaces. Device names are vendor 
    specific. Note that the naming convention will in some cases employ device 
    aliases, e.g., all x86_64 processors are identified with that simple tag 
    regardless of the exact processor name.

-mdevice-exclude=`<devices>`
  : Select list of devices to exclude where `<devices>` is a comma separated 
    list with no spaces. Device names are vendor specific. Note that the naming
    convention will 
    in some cases employ device aliases, e.g., all x86_64 processors are 
    identified with that simple tag regardless of the exact processor 
    name.

-mplatform=`<platforms>`
  : Select exclusive list of platforms to include where <platforms> is a 
    comma separated list with no spaces. 

-mplatform-exclude=`<platforms>`
  : Select list of platforms to exclude where `<platforms>` is a comma separated 
    list with no spaces.

-o `<output file>`
  : Specifiy the output filename for the final ELF object file. The default 
    naming convention for compiling a single OpenCL kernel file is the 
    filename base with the .o extension. The default naming convention 
    for compiling multiple OpenCL kernel files is out_clcc.o .

-s
  : Include only source the original source code in the CL-ELF object, i.e., 
    do not embed any device specific binaries. This will 
    require the kernels to be JIT compiled on all target platforms and devices. 

-v
  : Generate verbose diagnostic information.

--version
  : Print version information.


## clld: An Offline Linker for OpenCL

clld is an offline linker used to combine CL-ELF object files generated by the 
offline compilation of OpenCL kernel files using clcc. The output of clld can be 
re-linked using clld as many times as necessary, but can only be linked once to 
produce an ELF object or executable file using the conventional linker ld. In 
order to protect against multiple links using ld, hash values are included in 
CL-ELF object files such that multiple values can only be resolved with clld. 
The following is a synopsis of the usage for clld.

	clld [options] file1.o file2.o ... [-o output.o]

Options:

  
-b
  : Include only binaries in the CL-ELF object, i.e., do not embed the original 
    source code. This prevents the kernels from being JIT compiled on target 
    platforms and devices not included in the offline compilation.

-h --help
  : Print a brief help message.

-mall
  : Include binaries for all devices supported by all available platforms.

-mavail
  : Include binaries for only those devices available on the host system.

-mdevice=`<devices>`
  : Select exclusive list of devices to include where `<devices>` is a comma 
    separated list with no spaces. Device names are vendor specific. 
    Note that the naming convention will in some cases employ 
    device aliases, e.g., all x86_64 processors are identified with that simple 
    tag regardless of the exact processor name.

-mdevice-exclude=`<devices>`
  : Select list of devices to exclude where `<devices>` is a comma separated 
    list with no spaces. Device names are vendor specific. Note that the 
    naming convention will 
    in some cases employ device aliases, e.g., all x86_64 processors are 
    identified with that simple tag regardless of the exact processor name.

-mplatform=`<platforms>`
  : Select exclusive list of platforms to include where `<platforms>` is a 
    comma separated list with no spaces. 
  
-mplatform-exclude=`<platforms>`
  : Select list of platforms to exclude where `<platforms>` is a comma 
    separated list with no spaces.

-o `<output file>`
  : Specify the output filename for the final ELF object file. The default naming 
    convention for compiling a single OpenCL kernel file is the filename 
    base with the .o extension. The default naming convention for compiling 
    multiple OpenCL kernel files is out_clcc.o .

-s
  : Include only source the original source code in the CL-ELF object, i.e., 
    do not embed any device specific binaries. This will 
    require the kernels to be JIT compiled on all target platforms and devices. 

-v
  : Generate verbose diagnostic information.

--version
  : Print version information.


## clnm: Show the Contents of CL-ELF Sections

clnm is a tool analogous to the conventional nm program and allows the programer 
to examine the contents of the CL-ELF sections in an ELF object or executable. 
The following example shows the output from clnm used to examine an executable 
linked with OpenCL kernels compiled using clcc:

~~~
]clnm bdt_nbody.x
clnm: 'nbody_kern.cl' bin [amdapp:Cypress]
clnm: 'nbody_kern.cl' bin [amdapp:Cayman]
clnm: 'nbody_kern.cl' bin [amdapp:ATI RV770]
clnm: 'nbody_kern.cl' bin [amdapp:ATI RV710]
clnm: 'nbody_kern.cl' bin [amdapp:ATI RV730]
clnm: 'nbody_kern.cl' bin [amdapp:Juniper]
clnm: 'nbody_kern.cl' bin [amdapp:Redwood]
clnm: 'nbody_kern.cl' bin [amdapp:Cedar]
clnm: 'nbody_kern.cl' bin [amdapp:WinterPark]
clnm: 'nbody_kern.cl' bin [amdapp:BeaverCreek]
clnm: 'nbody_kern.cl' bin [amdapp:Loveland]
clnm: 'nbody_kern.cl' bin [amdapp:Barts]
clnm: 'nbody_kern.cl' bin [amdapp:Turks]
clnm: 'nbody_kern.cl' bin [amdapp:Caicos]
clnm: 'nbody_kern.cl' bin [amdapp:x86_64]
clnm: 'nbody_kern.cl' bin [coprthr:x86_64]
clnm: 'nbody_kern.cl' ksym copy_kern
clnm: 'nbody_kern.cl' ksym nbody_kern
clnm: 'nbody_kern.cl' ksym copy_kern
clnm: 'nbody_kern.cl' ksym nbody_kern
clnm: 'nbody_kern.cl' src [<generic>]
~~~


## cldebug: Compute Layer Debug Interface

cldebug provides an interface to debug information generated by the various
libraries and tools provided in the SDK.  

	cldebug [-v level] [-t tempdir] -- ./program [options ...]

-v level
  : set the level of reporting

-t tempdir
  : set the full path to a temp directory to use for JIT compilation; 
    specifying this option will also prevent the temporary files from being
    removed in order to allow them to be examined


