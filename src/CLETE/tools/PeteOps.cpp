// -*- C++ -*-
// ACL:license
// ----------------------------------------------------------------------
// This software and ancillary information (herein called "SOFTWARE")
// called PETE (Portable Expression Template Engine) is
// made available under the terms described here.  The SOFTWARE has been
// approved for release with associated LA-CC Number LA-CC-99-5.
// 
// Unless otherwise indicated, this SOFTWARE has been authored by an
// employee or employees of the University of California, operator of the
// Los Alamos National Laboratory under Contract No.  W-7405-ENG-36 with
// the U.S. Department of Energy.  The U.S. Government has rights to use,
// reproduce, and distribute this SOFTWARE. The public may copy, distribute,
// prepare derivative works and publicly display this SOFTWARE without 
// charge, provided that this Notice and any statement of authorship are 
// reproduced on all copies.  Neither the Government nor the University 
// makes any warranty, express or implied, or assumes any liability or 
// responsibility for the use of this SOFTWARE.
// 
// If SOFTWARE is modified to produce derivative works, such modified
// SOFTWARE should be clearly marked, so as not to confuse it with the
// version available from LANL.
// 
// For more information about PETE, send e-mail to pete@acl.lanl.gov,
// or visit the PETE web page at http://www.acl.lanl.gov/pete/.
// ----------------------------------------------------------------------
// ACL:license

///////////////////////////////////////////////////////////////////////////////
//
// WARNING: THIS FILE WAS GENERATED AUTOMATICALLY!
// YOU SHOULD MODIFY THE INPUT FILES INSTEAD OF CHANGING THIS FILE DIRECTLY!
//
// THE FOLLOWING INPUT FILES WERE USED TO MAKE THIS FILE:
//
// MakeOperators
// PeteOps.in
//
///////////////////////////////////////////////////////////////////////////////

#include "OperatorDescriptor.h"
#include <vector>
#include <map>
#include <string>
using std::map;
using std::vector;
using std::string;


void peteOps(map<string,vector<OperatorDescriptor> > &m)
{
  m["assignOp"].push_back(
              OperatorDescriptor("OpAssign",
                                 "assign",
                                 "return (const_cast<T1 &>(a) = b);",
                                 ""));
  m["binaryAssignOps"].push_back(
              OperatorDescriptor("OpAddAssign",
                                 "operator+=",
                                 "(const_cast<T1 &>(a) += b); return const_cast<T1 &>(a);",
                                 ""));
  m["binaryAssignOps"].push_back(
              OperatorDescriptor("OpSubtractAssign",
                                 "operator-=",
                                 "(const_cast<T1 &>(a) -= b); return const_cast<T1 &>(a);",
                                 ""));
  m["binaryAssignOps"].push_back(
              OperatorDescriptor("OpMultiplyAssign",
                                 "operator*=",
                                 "(const_cast<T1 &>(a) *= b); return const_cast<T1 &>(a);",
                                 ""));
  m["binaryAssignOps"].push_back(
              OperatorDescriptor("OpDivideAssign",
                                 "operator/=",
                                 "(const_cast<T1 &>(a) /= b); return const_cast<T1 &>(a);",
                                 ""));
  m["binaryAssignOps"].push_back(
              OperatorDescriptor("OpModAssign",
                                 "operator%=",
                                 "(const_cast<T1 &>(a) %= b); return const_cast<T1 &>(a);",
                                 ""));
  m["binaryAssignOps"].push_back(
              OperatorDescriptor("OpBitwiseOrAssign",
                                 "operator|=",
                                 "(const_cast<T1 &>(a) |= b); return const_cast<T1 &>(a);",
                                 ""));
  m["binaryAssignOps"].push_back(
              OperatorDescriptor("OpBitwiseAndAssign",
                                 "operator&=",
                                 "(const_cast<T1 &>(a) &= b); return const_cast<T1 &>(a);",
                                 ""));
  m["binaryAssignOps"].push_back(
              OperatorDescriptor("OpBitwiseXorAssign",
                                 "operator^=",
                                 "(const_cast<T1 &>(a) ^= b); return const_cast<T1 &>(a);",
                                 ""));
  m["binaryAssignOps"].push_back(
              OperatorDescriptor("OpLeftShiftAssign",
                                 "operator<<=",
                                 "(const_cast<T1 &>(a) <<= b); return const_cast<T1 &>(a);",
                                 ""));
  m["binaryAssignOps"].push_back(
              OperatorDescriptor("OpRightShiftAssign",
                                 "operator>>=",
                                 "(const_cast<T1 &>(a) >>= b); return const_cast<T1 &>(a);",
                                 ""));
  m["binaryBoolOps"].push_back(
              OperatorDescriptor("OpLT",
                                 "operator<",
                                 "return (a < b);",
                                 ""));
  m["binaryBoolOps"].push_back(
              OperatorDescriptor("OpLE",
                                 "operator<=",
                                 "return (a <= b);",
                                 ""));
  m["binaryBoolOps"].push_back(
              OperatorDescriptor("OpGT",
                                 "operator>",
                                 "return (a > b);",
                                 ""));
  m["binaryBoolOps"].push_back(
              OperatorDescriptor("OpGE",
                                 "operator>=",
                                 "return (a >= b);",
                                 ""));
  m["binaryBoolOps"].push_back(
              OperatorDescriptor("OpEQ",
                                 "operator==",
                                 "return (a == b);",
                                 ""));
  m["binaryBoolOps"].push_back(
              OperatorDescriptor("OpNE",
                                 "operator!=",
                                 "return (a != b);",
                                 ""));
  m["binaryBoolOps"].push_back(
              OperatorDescriptor("OpAnd",
                                 "operator&&",
                                 "return (a && b);",
                                 ""));
  m["binaryBoolOps"].push_back(
              OperatorDescriptor("OpOr",
                                 "operator||",
                                 "return (a || b);",
                                 ""));
  m["binaryLeftOps"].push_back(
              OperatorDescriptor("OpLeftShift",
                                 "operator<<",
                                 "return (a << b);",
                                 ""));
  m["binaryLeftOps"].push_back(
              OperatorDescriptor("OpRightShift",
                                 "operator>>",
                                 "return (a >> b);",
                                 ""));
  m["binaryOps"].push_back(
              OperatorDescriptor("OpAdd",
                                 "operator+",
                                 "return (a + b);",
                                 ""));
  m["binaryOps"].push_back(
              OperatorDescriptor("OpSubtract",
                                 "operator-",
                                 "return (a - b);",
                                 ""));
  m["binaryOps"].push_back(
              OperatorDescriptor("OpMultiply",
                                 "operator*",
                                 "return (a * b);",
                                 ""));
  m["binaryOps"].push_back(
              OperatorDescriptor("OpDivide",
                                 "operator/",
                                 "return (a / b);",
                                 ""));
  m["binaryOps"].push_back(
              OperatorDescriptor("OpMod",
                                 "operator%",
                                 "return (a % b);",
                                 ""));
  m["binaryOps"].push_back(
              OperatorDescriptor("OpBitwiseAnd",
                                 "operator&",
                                 "return (a & b);",
                                 ""));
  m["binaryOps"].push_back(
              OperatorDescriptor("OpBitwiseOr",
                                 "operator|",
                                 "return (a | b);",
                                 ""));
  m["binaryOps"].push_back(
              OperatorDescriptor("OpBitwiseXor",
                                 "operator^",
                                 "return (a ^ b);",
                                 ""));
  m["binaryOps"].push_back(
              OperatorDescriptor("FnLdexp",
                                 "ldexp",
                                 "return (ldexp(a,b));",
                                 ""));
  m["binaryOps"].push_back(
              OperatorDescriptor("FnPow",
                                 "pow",
                                 "return (pow(a,b));",
                                 ""));
  m["binaryOps"].push_back(
              OperatorDescriptor("FnFmod",
                                 "fmod",
                                 "return (fmod(a,b));",
                                 ""));
  m["binaryOps"].push_back(
              OperatorDescriptor("FnArcTan2",
                                 "atan2",
                                 "return (atan2(a,b));",
                                 ""));
  m["trinaryOps"].push_back(
              OperatorDescriptor("FnWhere",
                                 "where",
                                 "if (a) return b; else return c;",
                                 ""));
  m["unaryBoolOps"].push_back(
              OperatorDescriptor("OpNot",
                                 "operator!",
                                 "return (!a);",
                                 ""));
  m["unaryCastOps"].push_back(
              OperatorDescriptor("OpCast",
                                 "peteCast",
                                 "return T1(a);",
                                 ""));
  m["unaryOps"].push_back(
              OperatorDescriptor("FnArcCos",
                                 "acos",
                                 "return (acos(a));",
                                 ""));
  m["unaryOps"].push_back(
              OperatorDescriptor("FnArcSin",
                                 "asin",
                                 "return (asin(a));",
                                 ""));
  m["unaryOps"].push_back(
              OperatorDescriptor("FnArcTan",
                                 "atan",
                                 "return (atan(a));",
                                 ""));
  m["unaryOps"].push_back(
              OperatorDescriptor("FnCeil",
                                 "ceil",
                                 "return (ceil(a));",
                                 ""));
  m["unaryOps"].push_back(
              OperatorDescriptor("FnCos",
                                 "cos",
                                 "return (cos(a));",
                                 ""));
  m["unaryOps"].push_back(
              OperatorDescriptor("FnHypCos",
                                 "cosh",
                                 "return (cosh(a));",
                                 ""));
  m["unaryOps"].push_back(
              OperatorDescriptor("FnExp",
                                 "exp",
                                 "return (exp(a));",
                                 ""));
  m["unaryOps"].push_back(
              OperatorDescriptor("FnFabs",
                                 "fabs",
                                 "return (fabs(a));",
                                 ""));
  m["unaryOps"].push_back(
              OperatorDescriptor("FnFloor",
                                 "floor",
                                 "return (floor(a));",
                                 ""));
  m["unaryOps"].push_back(
              OperatorDescriptor("FnLog",
                                 "log",
                                 "return (log(a));",
                                 ""));
  m["unaryOps"].push_back(
              OperatorDescriptor("FnLog10",
                                 "log10",
                                 "return (log10(a));",
                                 ""));
  m["unaryOps"].push_back(
              OperatorDescriptor("FnSin",
                                 "sin",
                                 "return (sin(a));",
                                 ""));
  m["unaryOps"].push_back(
              OperatorDescriptor("FnHypSin",
                                 "sinh",
                                 "return (sinh(a));",
                                 ""));
  m["unaryOps"].push_back(
              OperatorDescriptor("FnSqrt",
                                 "sqrt",
                                 "return (sqrt(a));",
                                 ""));
  m["unaryOps"].push_back(
              OperatorDescriptor("FnTan",
                                 "tan",
                                 "return (tan(a));",
                                 ""));
  m["unaryOps"].push_back(
              OperatorDescriptor("FnHypTan",
                                 "tanh",
                                 "return (tanh(a));",
                                 ""));
  m["unaryOps"].push_back(
              OperatorDescriptor("OpUnaryMinus",
                                 "operator-",
                                 "return (-a);",
                                 ""));
  m["unaryOps"].push_back(
              OperatorDescriptor("OpUnaryPlus",
                                 "operator+",
                                 "return (+a);",
                                 ""));
  m["unaryOps"].push_back(
              OperatorDescriptor("OpBitwiseNot",
                                 "operator~",
                                 "return (~a);",
                                 ""));
  m["unaryOps"].push_back(
              OperatorDescriptor("OpIdentity",
                                 "PETE_identity",
                                 "return (a);",
                                 ""));
}

// ACL:rcsinfo
// ----------------------------------------------------------------------
// $RCSfile: PeteOps.cpp,v $   $Author: sa_smith $
// $Revision: 1.5 $   $Date: 2000/08/03 00:18:02 $
// ----------------------------------------------------------------------
// ACL:rcsinfo
